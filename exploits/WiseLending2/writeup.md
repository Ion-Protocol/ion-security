# Wise Lending

Wise lending is a cross-margin lending market (similar to aave) and yield aggregator.

## Overview

On January 12, 2024 UTC, Wise Lending was exploited for a second time with an estimated loss of around 178 ETH. This hack was the result of yet another uninitialized-pool/rounding-error combo, however, what makes this incident (extra) educational to study is the protocol implemented many safeguards to protect against this sort of attack.

Since donations are a common element of these attacks, Wise Lending implemented a mechanism to smooth out the distribution of massive token balance spikes. They also followed the recommended practice for always rounding in the protocol's favor.

However, these mechanisms were either bypassed, or ended up working against the protocol.

## Technical Analysis

### Prerequisite Understanding

Within a WiseLending pool, a position can be represented as shares of the total pool, or as an underlying amount. Over the lifetime of a position, the share count is static, but as interest accrues, the underlying amount allocated to the shares increases. The conversion between shares and underlying amount is measured by another variable: `pseudoTotalPool`. At any given moment, `x` shares has a given claim of `x * pseudoTotalPool / totalShares`.

When a user deposit or withdraws `y` amount of lender liquidity, `pseudoTotalPool` will be incremented or decremented by `y` to reflect that. When interest is accrued (before every action with the lending pool), this will be done by increasing the `pseudoTotalPool` value. This increases the amount of underlying allocated to `x` shares. So `pseudoTotalPool` would represent the amount of underlying owed to lenders at any time (whether or not the liquidity exists to service it).

At initialization, `pseudoTotalPool` and `totalShares` are both set to 1.

In solidity, this calculation is subject to rounding errors. So WiseLending performs all rounding in the protocol's favor. The WiseLending API will provide two ways to deposit and two ways to withdraw, always rounding in the protocol's favor.

| API Method                                  | Rounding Direction                                                   |
| ------------------------------------------- | -------------------------------------------------------------------- |
| Deposit with desired `shareCountOut`        | `underlyingAmountIn` (to receive `shareCountOut`) is rounded up      |
| Deposit with desired `underlyingAmountIn`   | `shareCountOut` (given for `underlyingAmountIn`) is rounded down     |
| Withdraw with desired `shareCountToBurn`    | `underlyingAmountOut` (for `shareCountToBurn` burnt) is rounded down |
| Withdraw with desired `underlyingAmountOut` | `shareCountToBurn` (to receive `underlyingAmountOut`) is rounded up  |

### The Attack

This attack was only possible because of an uninitialized pool. [This](https://etherscan.io/tx/0x48470cb3be62d8fa656363e2bbe6a598253e40efda304c7311f0087cf5c84f93) was the transaction that created the pool for PLP-stETH-Dec2025 with no liquidity.

There are 7 contracts relevant to this attack. There is a primary, "Orchestrator" contract and there are 6 other contracts used to execute borrows that would never be repaid (more on the 6 child contracts later).

|                     | `address`                                                                                                             |
| ------------------- | --------------------------------------------------------------------------------------------------------------------- |
| Orchestrator        | (0x91c49cc7fbfe8f70aceeb075952cd64817f9d82c)[https://etherscan.io/address/0x91c49cc7fbfe8f70aceeb075952cd64817f9d82c] |
| Borrower Contract 1 | (0x3a0eeedd13582a27f61741388d3435f7291e889b)[https://etherscan.io/address/0x3a0eeedd13582a27f61741388d3435f7291e889b] |
| Borrower Contract 2 | (0xd68e5e90aaafcf519d47ecdb9932831edb40f467)[https://etherscan.io/address/0xd68e5e90aaafcf519d47ecdb9932831edb40f467] |
| Borrower Contract 3 | (0x51ffb04e815c0514203606c8eaeca7ada651263a)[https://etherscan.io/address/0x51ffb04e815c0514203606c8eaeca7ada651263a] |
| Borrower Contract 4 | (0x15b9485d154d7101a478f40ad5d2284dce9e5e14)[https://etherscan.io/address/0x15b9485d154d7101a478f40ad5d2284dce9e5e14] |
| Borrower Contract 5 | (0x0307fde47eef656d39cd0964bf03a1655ff40dd7)[https://etherscan.io/address/0x0307fde47eef656d39cd0964bf03a1655ff40dd7] |
| Borrower Contract 6 | (0x130f573c04dad56990a26cef055b6358d98bcbdc)[https://etherscan.io/address/0x130f573c04dad56990a26cef055b6358d98bcbdc] |

The attack was carried out in two different transactions. The first [one](https://etherscan.io/tx/0x67d6c554314c9b306d683afb3bc4a10e70509ceb0fdf8415a5e270a91fae52de) was a setup for the attack. Positions on Wise Lending are attached to an NFT so this transaction minted an NFT for the "Orchestrator," deposited 10_000_000_000 wei of PLP-stETH-Dec2025 (very small amount) on this NFT, created 6 Borrower contracts, and minted NFTs for the 6 contracts so that they could create positions on WiseLending as well. At this point, there are 10_000_000_001 wei of shares representing ownership of 10_000_000_000 wei of PLP-stETH-Dec2025 and the `pseudoTotalPool` value is 10_000_000_001.

The attacker also donated 48_049_495_766_323_824 wei (~0.04) PLP-stETH-Dec2025 to the pool. This donation will allow some interest accrual. Since donations are such a common attack vector for inflation attacks, WiseLending only distributes donations as interest in small chunks instead of just immediately distributing the total token balance, so the interest accrual will be small.

The second (transaction)[https://etherscan.io/tx/0x04e16a79ff928db2fa88619cdd045cdfc7979a61d836c9c9e585b3d6f6d8bc31] is where the actual attack was executed.

It began with a flashloan of 1,100.00 stETH which was used to mint around 518 (518e18) PLP-stETH-2025.

The next action withdraws all (10_000_000_000) of the attacker's shares. At the beginning of the interaction, this triggers an interest accrual and distributes a small amount of the donated value. The `pseudoTotalPool` goes from 10_000_000_001 to 10_000_015_263. After the interest is accrued, the actual withdrawal is processed; the 10_000_000_000 shares are now worth 10_000_015_261 underlying (the amount was rounded down). The resulting state is that the attacker has 0 shares, the `pseudoTotalPool` is 2, and the total amount of shares is 1. Notice how the `pseudoTotalPool` has increased. Since the withdrawal amount sent out the attacker was rounded down, that extra value remained in the protocol.

After this, the attacker (through the "Orchestrator") repeatedly deposited `2 * pseudoTotalPool - 1` into the pool and then withdrew 1 unit. These values were carefully chosen. If a user deposits `2 * pseudoTotalPool` units of the underlying, the protocol would mint 2 shares. The chosen deposit amount is right below that threshold and mints 1 share for the attacker. Withdrawing exactly 1 unit burns 1 share.

What is the effect of this? Every deposit increases the `pseudoTotalPool` by `2 * pseudoTotalPool - 1` and the withdraw decreases it by 1. So every iteration of deposit and withdraw increases the `pseudoTotalPool` by `2 * pseudoTotalPool - 2`. However, the attacker is losing PLP-stETH-Dec2025 in the pool's favor to perform this inflation. Note that through all these iterations, the total share count remains at 1 (the value it is initialized to).

_Since these actions were happening directly through protocol actions, the attacker was able to effectively "donate" to the protocol through its rounding behavior, side-stepping the time-delayed donation distribution_.

At the end of these iterations the `pseudoTotalPool` had jumped from 2 to `36472996377170786404`. After this, the attacker performed one final deposit to mint 6 shares of the pool to yield a new `pseudoTotalPool` of `255310974640195504834`. At this point, the "Orchestrator" contract owns the entire pool.

The next step in the attack was to use this inflated valuation to perform "overcollateralized" borrows. This is where the Borrower contracts come in. "Borrower Contract 1" is sent just enough PLP-stETH-Dec2025 (~36 PLP-stETH-Dec2025) to mint 1 share. That one share was valued at ~75ETH worth of collateral from the eyes of the protocol and allowed a borrow value of ~56ETH. So that one share was used to perform an overcollateralized borrow of ~43 wstETH (valued at ~50 ETH at the time). These funds were transferred to the "Orchestrator".

Finally, "Borrower Contract 1" will try to withdraw exactly one unit of PLP-stETH-Dec2025. This would be a very small fraction (`1 / pseudoTotalPool`) but gets rounded up to 1 share so that share is burnt. But how is this possible if burning that share means that the borrow of the 43 wstETH is now not collateralized? Let's take a look at how withdrawal solvency is checked:

```
   function checkBorrowLimit(
        uint256 _nftId,
        address _poolToken,
        uint256 _amount
    )
        public
        view
    {
        uint256 borrowAmount = overallETHBorrow(
            _nftId
        );

        if (borrowAmount == 0) {
            return;
        }

        uint256 withdrawValue = WISE_ORACLE.getTokensInETH(
            _poolToken,
            _amount
        )
            * WISE_LENDING.lendingPoolData(_poolToken).collateralFactor
            / PRECISION_FACTOR_E18;

        bool state = borrowPercentageCap
            * (overallETHCollateralsWeighted(_nftId) - withdrawValue)
            / PRECISION_FACTOR_E18
            < borrowAmount;

        if (state == true) {
            revert ResultsInBadDebt();
        }
    }
```

The solvency check calculates the borrow amount of the position. This was ~50ETH. Now when assessing the value being withdrawn from the protocol, it looks at the _amount requested for withdrawal_ instead of the _amount of shares that would be burned from the withdrawal_. **This is the critical vulnerability**. It uses the oracle to value the 1 wei of PLP-stETH-Dec2025 being withdrawn at 2 wei of ETH. Then, when checking that the borrow is still overcollateralized, uses `~75ETH (original collateral value) - 2 wei` instead of `~75ETH (original collateral value) - [value from burning the share amount]`.

A similar process was followed for Borrow Contracts 2 - 6.

- Borrower Contract 2 was sent ~41 PLP-stETH-Dec2025 and "borrowed" ~50 wstETH
- Borrower Contract 3 was sent ~47 PLP-stETH-Dec2025 and "borrowed" ~23 PLP-stETH-Dec2025 and ~10 wstETH
- Borrower Contract 4 was sent ~54 PLP-stETH-Dec2025 and "borrowed" ~73 WETH
- Borrower Contract 5 was sent ~62 PLP-stETH-Dec2025 and "borrowed" ~27 PLP-stETH-Dec2025, ~18 WETH, 9k USDC, 2k USDT, and 5k DAI
- Borrower Contract 6 was sent ~71 PLP-stETH-Dec2025 and "borrowed" ~48 PLP-stETH-Dec2025

After all of their "borrows", their one share was burnt. What all of these borrows were essentially doing was moving value from all the other pools in the protocol into the PLP-stETH-Dec2025 pool--a pool with only 6 shares in existence, all controlled by the attacker's "Orchestrator".

The final move was to withdraw all the PLP-stETH-Dec2025 in the pool, burning the 6 remaining shares. Game Over.

PLP-stETH-Dec2025 was sold back into stETH, flashloan was repaid, and attacker exited all tokens to ETH.

## Implications for Ion V1

Ion Protocol is not vulnerable to this type of attack since collaterals do not go through this type of two-factor valuation; as such there is no room for rounding errors in collateral valuations. Nevertheless, this incident clearly illustrates that implementing rounding in a protocol's favor, as seen with Ion, does not inherently ensure complete security. On the contrary, it sheds light on an alternative perspective: favoring a protocol through rounding is akin to making a donation; which tend to be integral parts of these sort of attacks.
